# プロジェクト原則

**バージョン**: 1.1.0
**最終更新日**: 2026-01-30
**ステータス**: 有効

## 目的

このドキュメントは、AI-SDDワークフロー デモプレゼンテーションプロジェクトの開発を統制する非交渉原則と基準を定義します。すべてのコード、仕様、設計判断はこれらの原則に従う必要があります。

## 原則階層

```
1. ビジネス原則（最優先）
   ↓
2. アーキテクチャ原則
   ↓
3. 開発手法原則
   ↓
4. 技術制約
```

優先度が高い原則が低い原則に優先します。

---

## 1. ビジネス原則（最優先）

### B-001: プレゼンテーション品質の優先

**原則**: プレゼンテーションの視覚的品質と伝達力を最優先とする。AI-SDDワークフローの価値を聴衆に正確に伝えることが目的である。

**適用範囲**: すべてのスライドコンポーネントとスタイリング

**検証方法**:

- [ ] スライドの内容がAI-SDDワークフローの価値を正確に伝えているか
- [ ] 視覚的な表現が情報の理解を助けているか
- [ ] 1280x720の解像度で正しく表示されるか

**違反例**:

- 技術的な正確さを犠牲にした誇張表現
- 読みにくいフォントサイズやカラーコントラスト

**準拠例**:

- 明確なビジュアル階層による情報設計
- AI-SDDの各フェーズを分かりやすく図示

---

### B-002: コンテンツの正確性

**原則**: プレゼンテーションで説明するAI-SDDワークフローの内容は、実際のプラグイン機能と一致していなければならない

**適用範囲**: すべてのスライドコンテンツ

**検証方法**:

- [ ] 説明されている機能がプラグインに実際に存在するか
- [ ] コマンド名やフロー図が最新のプラグイン仕様と一致しているか

---

## 2. アーキテクチャ原則

### A-001: コンポーネント分離

**原則**: UIの各関心事を独立したコンポーネント・モジュールとして実装し、追加・削除・並べ替えを容易にする

**適用範囲**: `src/components/`, `src/layouts/`

**検証方法**:

- [ ] 各コンポーネントが単一の責務を持つか
- [ ] コンポーネント間に不要な直接的依存関係がないか
- [ ] レイアウトコンポーネントと表示コンポーネントが分離されているか

**違反例**:

- 複数の責務を1つのコンポーネントに結合
- コンポーネント間で状態を直接共有
- レイアウトロジックとコンテンツ描画ロジックの混在

**準拠例**:

- `SlideRenderer.tsx` でレイアウト別の描画関数を分離
- `ComponentRegistry.tsx` でコンポーネントの登録・解決を一元管理
- `src/layouts/` でレイアウトラッパー（`TitleLayout`, `ContentLayout` 等）を個別に定義

---

### A-002: スタイルの階層管理

**原則**: スタイリングは3層モデル（グローバルCSS → CSS Modules → MUI sx prop）で管理し、各層の責務を明確に分離する。すべての色・フォントはCSS変数（`--theme-*`）経由で参照し、色値のハードコードを禁止する。

**適用範囲**: すべてのスタイリング

**検証方法**:

- [ ] テーマカラー・フォント定義が `src/styles/global.css` のCSS変数として管理されているか
- [ ] 複雑なコンポーネント固有スタイルにCSS Modules（`*.module.css`）が使用されているか
- [ ] インラインの微調整にのみ MUI `sx` prop が使用されているか
- [ ] 色値が `--theme-*` CSS変数経由で参照されているか（ハードコードされていないか）
- [ ] テーマ適用が `applyTheme.ts` 経由で行われているか

**違反例**:

- コンポーネント内で `color: '#e07a5f'` のように色値をハードコード
- グローバルCSSにコンポーネント固有のスタイルを追加
- CSS Modules を使うべき複雑なスタイルを MUI sx prop で記述

**準拠例**:

- `src/styles/global.css` でテーマCSS変数（`--theme-primary`, `--theme-background` 等）を定義
- `color: 'var(--theme-text-body)'` のようにCSS変数で色を参照
- `Timeline.module.css` のようなCSS Modulesでコンポーネント固有スタイルを管理
- `applyTheme.ts` でCSS変数への動的テーマ適用

---

### A-003: データ駆動型スライドアーキテクチャ

**原則**: スライドはReactコンポーネントではなくJSONデータで定義する。スライドの内容・構造・レイアウトはすべて `slides.json` のデータにより決定され、Reactコンポーネントはデータの描画のみを担当する。

**適用範囲**: スライドデータ定義、`src/data/`, `src/components/SlideRenderer.tsx`

**検証方法**:

- [ ] スライドの内容がJSONデータ（`public/slides.json` または `src/data/default-slides.json`）で定義されているか
- [ ] `SlideRenderer` がデータの `layout` フィールドに基づいて描画を切り替えているか
- [ ] 新しいスライドの追加がJSONデータの追加のみで可能か
- [ ] スライドの順序変更がJSONの配列順序変更のみで可能か

**違反例**:

- スライド内容をReactコンポーネント内にハードコード
- 特定スライド向けの専用コンポーネントファイルを作成
- スライド順序をコード内で制御

**準拠例**:

- `public/slides.json` でスライドデータを外部定義
- `src/data/default-slides.json` でデフォルトテンプレートを提供
- `SlideRenderer.tsx` の `renderSlide()` で `layout` フィールドに基づく描画関数の切り替え

---

### A-004: 多層コンポーネントレジストリ

**原則**: コンポーネントの登録と解決は `ComponentRegistry` で一元管理し、カスタム → デフォルト → フォールバックの3層優先順位で解決する。

**適用範囲**: `src/components/ComponentRegistry.tsx`, アドオンシステム

**検証方法**:

- [ ] すべてのカスタムコンポーネントが `ComponentRegistry` 経由で登録されているか
- [ ] `resolveComponent()` がカスタム → デフォルト → フォールバックの順で解決するか
- [ ] アドオンが `window.__ADDON_REGISTER__()` 経由で `registerComponent()` を呼び出しているか

**違反例**:

- コンポーネントを `ComponentRegistry` を介さずに直接インポート
- 解決優先順位を無視したコンポーネント登録
- アドオンからデフォルトコンポーネントを上書きせずに別の仕組みで登録

**準拠例**:

- `ComponentRegistry.tsx` の `resolveComponent()`:
  ```typescript
  customComponents.get(name) ?? defaultComponents.get(name) ?? FallbackComponent
  ```
- `registerDefaults.tsx` でデフォルトコンポーネントを一括登録
- アドオンの `entry.ts` で `registerComponent()` を使用したカスタム登録

---

### A-005: フォールバックファースト設計

**原則**: すべてのデータ参照・コンポーネント解決・外部リソース読み込みにおいて、失敗時の安全なフォールバックを提供する。エラー状態でもプレゼンテーションが表示可能であること。

**適用範囲**: データロード、コンポーネント解決、テーマ適用、画像表示

**検証方法**:

- [ ] データバリデーション失敗時にデフォルトデータへフォールバックするか
- [ ] 未登録コンポーネント参照時に `FallbackComponent` が表示されるか
- [ ] カスタム `slides.json` が存在しない場合に `default-slides.json` が使用されるか
- [ ] テーマ設定エラー時にデフォルトテーマで表示されるか

**違反例**:

- バリデーション失敗時にエラーをスローしてアプリを停止
- 未登録コンポーネント参照時に空白や壊れた表示
- 外部リソース読み込み失敗時にフォールバックなし

**準拠例**:

- `loader.ts` の `loadPresentationData()` でバリデーション失敗時にデフォルトデータを返却
- `ComponentRegistry.tsx` の `resolveComponent()` で `FallbackComponent` を最終手段として提供
- `main.tsx` で `slides.json` 取得失敗時に `default-slides.json` を使用

---

## 3. 開発手法原則

### D-001: Specification-Driven

**原則**: 仕様書なしで実装しない

**適用範囲**: すべての新機能・変更

**検証方法**:

- [ ] `*_spec.md` が存在する
- [ ] `*_design.md` が存在する
- [ ] 仕様書が最新（実装前に更新されている）

**違反例**:

- 口頭指示のみで実装開始
- 仕様書が古いまま実装

**準拠例**:

- Specify → Plan → Tasks → Implement のフローを遵守
- 仕様書を真実の源（Single Source of Truth）として管理

---

### D-002: バリデーション駆動型データ処理

**原則**: 外部から取得するデータ（JSONファイル、ユーザー入力等）は、使用前に必ずバリデーションを行い、型安全性を保証する。バリデーションエラーは構造化された形式で収集・報告する。

**適用範囲**: `src/data/`, 外部データ取得処理

**検証方法**:

- [ ] 外部データに対して型ガード関数またはバリデーション関数が実装されているか
- [ ] バリデーションエラーがパス・メッセージ・期待値・実際値を含む構造化形式で収集されるか
- [ ] バリデーション通過後にTypeScriptの型ナローイングが適用されるか

**違反例**:

- 外部JSONデータを型アサーション（`as`）のみでキャスト
- エラー情報なしの `boolean` 戻り値のみのバリデーション
- バリデーションをスキップしてデータを直接使用

**準拠例**:

- `loader.ts` の `validatePresentationData()`: 型ガード関数として実装（`data is PresentationData`）
- `loader.ts` の `getValidationErrors()`: パス・メッセージ・期待値・実際値を含む `ValidationError[]` を返却
- バリデーション成功後の安全な型ナローイング

---

## 開発標準

### コード品質

| 標準       | 要件          | ツール                    | 適用方法  |
|:---------|:------------|:-----------------------|:------|
| **型安全性** | 厳密な型チェック    | TypeScript strict mode | ビルド時  |

### ドキュメント

| 標準      | 要件                        | 配置場所                  | 更新頻度   |
|:--------|:--------------------------|:----------------------|:-------|
| **仕様書** | すべての機能に `*_spec.md` が必要   | `.sdd/specification/` | 実装前    |
| **設計書** | すべての実装に `*_design.md` が必要 | `.sdd/specification/` | 設計フェーズ |

## アーキテクチャ制約

### 技術スタック制約

| レイヤー         | 許可される技術                           | 理由                 |
|:-------------|:----------------------------------|:-------------------|
| **UI**       | React, TypeScript                 | 型安全性、コンポーネント指向     |
| **プレゼン**     | Reveal.js                         | スライド表示に特化したライブラリ   |
| **ビルドツール**   | Vite                              | 高速なHMRとビルド         |
| **スタイリング**   | CSS（カスタム）, CSS Modules, MUI sx prop | Reveal.jsとの親和性、階層的スタイル管理 |

### モジュール構成

```
src/
├── main.tsx            # エントリーポイント
├── App.tsx             # Reveal.js初期化・スライド配置
├── applyTheme.ts       # テーマ適用（CSS変数設定）
├── addon-bridge.ts     # アドオン向けグローバルAPI公開
├── components/         # UIコンポーネント（SlideRenderer, ComponentRegistry等）
├── layouts/            # レイアウトラッパー（TitleLayout, ContentLayout等）
├── hooks/              # カスタムフック（useReveal等）
├── data/               # データローダー・バリデーション・デフォルトデータ
└── styles/             # CSSスタイル（global.css, CSS Modules）
```

## 意思決定フレームワーク

技術的トレードオフに直面した場合、以下の順序で優先順位付けします：

1. **伝達力** - プレゼンテーションとして情報が伝わるか？
2. **正確性** - AI-SDDの仕様と一致しているか？
3. **シンプルさ** - 最もシンプルな解決策か？
4. **保守性** - スライドの追加・変更が容易か？

## 4. 技術制約

### T-001: TypeScript Strict Mode

**原則**: TypeScript の strict モードを有効にし、型安全性を確保する

**適用範囲**: すべてのソースコード

**検証方法**:

- [ ] `tsconfig.json` で `strict: true` が設定されている
- [ ] `noUnusedLocals` と `noUnusedParameters` が有効

**違反例**:

- `any` 型の使用
- 型アサーション（`as`）の多用

**準拠例**:

- すべてのコンポーネントに明確な型定義
- Reveal.js の型定義ファイル（`reveal.d.ts`）の維持

---

### T-002: Reveal.js 互換性

**原則**: Reveal.js の DOM 構造（`.reveal > .slides > section`）を維持し、プレゼンテーション機能との互換性を確保する

**適用範囲**: すべてのスライドコンポーネント

**検証方法**:

- [ ] 各スライドコンポーネントが `<section>` 要素を返しているか
- [ ] Reveal.js のクラス名やデータ属性が正しく設定されているか

---

### T-003: React-外部ライブラリのライフサイクル統合

**原則**: React管理外のライブラリ（Reveal.js等）は、`useEffect` のクリーンアップ関数で確実にリソースを解放し、メモリリークを防止する。

**適用範囲**: `src/hooks/`, React管理外ライブラリとの統合コード

**検証方法**:

- [ ] 外部ライブラリの初期化が `useEffect` 内で行われているか
- [ ] `useEffect` のクリーンアップ関数で `destroy()` 等のリソース解放が呼ばれているか
- [ ] DOM参照が `useRef` 経由で管理されているか
- [ ] 依存配列が適切に設定されているか

**違反例**:

- `useEffect` のクリーンアップ関数なしで外部ライブラリを初期化
- グローバル変数で外部ライブラリインスタンスを管理
- コンポーネント本体（レンダリング中）で外部ライブラリを初期化

**準拠例**:

- `useReveal.ts` での Reveal.js ライフサイクル管理:
  ```typescript
  useEffect(() => {
    const deck = new Reveal(deckRef.current, { /* config */ })
    deck.initialize()
    return () => { deck.destroy() }  // クリーンアップ
  }, [])
  ```
- `useRef<HTMLDivElement>` によるDOM参照の管理

---

## 原則追加のガイドライン

新しい原則を追加する際は、以下を考慮してください：

### 良い原則の条件

| 条件        | 説明                         |
|:----------|:---------------------------|
| **検証可能**  | チェックリストで検証できること            |
| **明確**    | 曖昧さがなく、準拠/違反の判断が明確であること    |
| **正当化可能** | なぜその原則が必要かが説明できること         |
| **実現可能**  | チーム全体が実践できること              |
| **永続的**   | 一時的な方針ではなく、長期的に守るべき原則であること |

## 関連ドキュメント

### この原則を参照すべきドキュメント

| ドキュメント                           | 参照方法                |
|:---------------------------------|:--------------------|
| `.sdd/SPECIFICATION_TEMPLATE.md` | 原則への言及セクションを含める     |
| `.sdd/DESIGN_DOC_TEMPLATE.md`    | 原則準拠のチェックリストを含める    |
| `*_spec.md`                      | 原則に基づいた設計を記述        |
| `*_design.md`                    | 設計判断が原則に準拠していることを明記 |

### 原則準拠の検証

```bash
/constitution validate
```

このコマンドで、すべての仕様書・設計書が原則に従っているかを自動検証できます。

---

## セマンティックバージョニング

原則のバージョンは以下のルールに従います：

| バージョン種別 | 用途                  | 例             |
|:--------|:--------------------|:--------------|
| Major   | 既存原則の削除・大幅変更（破壊的変更） | 1.0.0 → 2.0.0 |
| Minor   | 新しい原則の追加            | 1.0.0 → 1.1.0 |
| Patch   | 原則の表現修正、誤字修正        | 1.0.0 → 1.0.1 |

---

*この原則は生きたドキュメントです。チームの学びとプロジェクトのニーズに応じて進化すべきものです。*

## 変更履歴

### v1.1.0 (2026-01-30)

**原則の拡充と現状への整合**

- A-001: コンポーネント分離 — データ駆動型アーキテクチャに合わせて適用範囲・準拠例・違反例を更新
- A-002: スタイルの集約管理 → スタイルの階層管理 — 3層モデル（グローバルCSS + CSS Modules + MUI sx prop）とCSS変数テーマルールを明記
- A-003: データ駆動型スライドアーキテクチャ（新規）— JSONデータ駆動の設計原則
- A-004: 多層コンポーネントレジストリ（新規）— ComponentRegistry の3層優先解決
- A-005: フォールバックファースト設計（新規）— 全層での安全なフォールバック提供
- D-002: バリデーション駆動型データ処理（新規）— 構造化バリデーションパターン
- T-003: React-外部ライブラリのライフサイクル統合（新規）— useEffect + destroy() パターン
- 技術スタック制約: スタイリングに CSS Modules, MUI sx prop を追加
- モジュール構成: 現在のディレクトリ構造に更新（`src/slides/` を廃止、`components/`, `layouts/`, `data/`, `hooks/` 等を追加）

### v1.0.0 (2026-01-28)

**初版原則の確立**

- B-001: プレゼンテーション品質の優先
- B-002: コンテンツの正確性
- A-001: コンポーネント分離
- A-002: スタイルの集約管理
- D-001: Specification-Driven
- T-001: TypeScript Strict Mode
- T-002: Reveal.js 互換性
